"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropdownMenuItem = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const React = tslib_1.__importStar(require("react"));
const icons_1 = require("@gravity-ui/icons");
const Icon_1 = require("../Icon");
const Menu_1 = require("../Menu");
const theme_1 = require("../theme");
const DropdownMenu_classname_1 = require("./DropdownMenu.classname");
const DropdownMenuContext_1 = require("./DropdownMenuContext");
const DropdownMenuPopup_1 = require("./DropdownMenuPopup");
const useSubmenu_1 = require("./hooks/useSubmenu");
const DropdownMenuItem = (_a) => {
    var { text, action, items: subMenuItems, popupProps, closeMenu, children, path } = _a, props = tslib_1.__rest(_a, ["text", "action", "items", "popupProps", "closeMenu", "children", "path"]);
    const { toggle, data } = React.useContext(DropdownMenuContext_1.DropdownMenuContext);
    const menuItemRef = React.useRef(null);
    const direction = (0, theme_1.useDirection)();
    const { hasSubmenu, isSubmenuOpen, closeSubmenu, openSubmenu } = (0, useSubmenu_1.useSubmenu)({
        items: subMenuItems,
        path,
    });
    const handleCloseMenu = React.useCallback(() => {
        const close = () => {
            if (closeMenu) {
                closeMenu();
            }
            else {
                toggle(false);
            }
        };
        if (hasSubmenu) {
            closeSubmenu();
            // Wait for submenu to close
            requestAnimationFrame(close);
        }
        else {
            close();
        }
    }, [closeMenu, closeSubmenu, hasSubmenu, toggle]);
    const handleMenuItemClick = React.useCallback((event) => {
        if (hasSubmenu) {
            return;
        }
        action === null || action === void 0 ? void 0 : action(event, data);
        handleCloseMenu();
    }, [action, data, handleCloseMenu, hasSubmenu]);
    const extraProps = React.useMemo(() => {
        return Object.assign(Object.assign({}, props.extraProps), { onMouseEnter: (event) => {
                var _a, _b;
                (_b = (_a = props.extraProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                if (hasSubmenu) {
                    openSubmenu();
                }
            }, onMouseLeave: (event) => {
                var _a, _b;
                (_b = (_a = props.extraProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                if (hasSubmenu) {
                    closeSubmenu();
                }
            } });
    }, [props.extraProps, closeSubmenu, hasSubmenu, openSubmenu]);
    const subMenuPlacement = React.useMemo(() => (direction === 'rtl' ? ['left-start', 'right-start'] : ['right-start', 'left-start']), [direction]);
    const iconEnd = React.useMemo(() => hasSubmenu ? ((0, jsx_runtime_1.jsx)(Icon_1.Icon, { data: direction === 'rtl' ? icons_1.ChevronLeft : icons_1.ChevronRight, size: 10, className: (0, DropdownMenu_classname_1.cnDropdownMenu)('sub-menu-arrow') })) : (props.iconEnd), [hasSubmenu, direction, props.iconEnd]);
    return ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [(0, jsx_runtime_1.jsx)(Menu_1.Menu.Item, Object.assign({ ref: menuItemRef }, props, { extraProps: extraProps, onClick: handleMenuItemClick, iconEnd: iconEnd, children: text || children })), hasSubmenu && subMenuItems && ((0, jsx_runtime_1.jsx)(DropdownMenuPopup_1.DropdownMenuPopup, { popupProps: Object.assign(Object.assign({}, popupProps), { className: (0, DropdownMenu_classname_1.cnDropdownMenu)('sub-menu', popupProps === null || popupProps === void 0 ? void 0 : popupProps.className), placement: subMenuPlacement }), items: subMenuItems, path: path, open: isSubmenuOpen, anchorRef: menuItemRef, onClose: handleCloseMenu }))] }));
};
exports.DropdownMenuItem = DropdownMenuItem;
