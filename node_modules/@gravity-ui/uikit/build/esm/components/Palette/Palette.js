'use client';
import { jsx as _jsx } from "react/jsx-runtime";
import * as React from 'react';
import { useSelect } from '../../hooks';
import { useForkRef } from '../../hooks/useForkRef/useForkRef';
import { Button } from '../Button';
import { block } from '../utils/cn';
import { filterDOMProps } from '../utils/filterDOMProps';
import { usePaletteGrid } from './hooks';
import { getPaletteRows } from './utils';
import './Palette.css';
const b = block('palette');
export const Palette = React.forwardRef(function Palette(props, ref) {
    const { size = 'm', multiple = true, options = [], columns = 6, disabled, style, className, rowClassName, optionClassName, qa, onFocus, onBlur, } = props;
    const [focusedOptionIndex, setFocusedOptionIndex] = React.useState(undefined);
    const focusedOption = focusedOptionIndex === undefined ? undefined : options[focusedOptionIndex];
    const innerRef = React.useRef(null);
    const handleRef = useForkRef(ref, innerRef);
    const { value, handleSelection } = useSelect({
        value: props.value,
        defaultValue: props.defaultValue,
        multiple,
        onUpdate: props.onUpdate,
    });
    const rows = React.useMemo(() => getPaletteRows(options, columns), [columns, options]);
    const focusOnOptionWithIndex = React.useCallback((index) => {
        if (!innerRef.current)
            return;
        const $options = Array.from(innerRef.current.querySelectorAll(`.${b('option')}`));
        if (!$options[index])
            return;
        $options[index].focus();
        setFocusedOptionIndex(index);
    }, []);
    const tryToFocus = (newIndex) => {
        if (newIndex === focusedOptionIndex || newIndex < 0 || newIndex >= options.length) {
            return;
        }
        focusOnOptionWithIndex(newIndex);
    };
    const gridProps = usePaletteGrid({
        disabled,
        onFocus: (event) => {
            focusOnOptionWithIndex(0);
            onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
        },
        onBlur: (event) => {
            setFocusedOptionIndex(undefined);
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
        },
        whenFocused: focusedOptionIndex !== undefined && focusedOption
            ? {
                selectItem: () => handleSelection(focusedOption),
                nextItem: () => tryToFocus(focusedOptionIndex + 1),
                previousItem: () => tryToFocus(focusedOptionIndex - 1),
                nextRow: () => tryToFocus(focusedOptionIndex + columns),
                previousRow: () => tryToFocus(focusedOptionIndex - columns),
            }
            : undefined,
    });
    return (_jsx("div", Object.assign({}, filterDOMProps(props, { labelable: true }), gridProps, { ref: handleRef, className: b({ size }, className), style: style, "data-qa": qa, children: rows.map((row, rowNumber) => (_jsx("div", { className: b('row', rowClassName), role: "row", children: row.map((option) => {
                var _a;
                const isSelected = Boolean(value.includes(option.value));
                const focused = option === focusedOption;
                return (_jsx("div", { role: "gridcell", "aria-selected": focused ? 'true' : undefined, "aria-readonly": option.disabled, children: _jsx(Button, { className: b('option', optionClassName), tabIndex: -1, style: style, disabled: disabled || option.disabled, title: option.title, view: isSelected ? 'normal' : 'flat', selected: isSelected, extraProps: { value: option.value }, size: size, onClick: () => handleSelection(option), children: _jsx(Button.Icon, { children: (_a = option.content) !== null && _a !== void 0 ? _a : option.value }) }) }, option.value));
            }) }, `row-${rowNumber}`))) })));
});
Palette.displayName = 'Palette';
