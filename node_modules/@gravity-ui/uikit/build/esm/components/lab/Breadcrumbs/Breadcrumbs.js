'use client';
import { createElement as _createElement } from "react";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from 'react';
import { useForkRef, useResizeObserver } from '../../../hooks';
import { Button } from '../../Button';
import { DropdownMenu } from '../../DropdownMenu';
import { filterDOMProps } from '../../utils/filterDOMProps';
import { BreadcrumbItem } from './BreadcrumbItem';
import { BreadcrumbsSeparator } from './BreadcrumbsSeparator';
import i18n from './i18n';
import { b, shouldClientNavigate } from './utils';
import './Breadcrumbs.css';
function Item(_props) {
    return null;
}
export const Breadcrumbs = React.forwardRef(function Breadcrumbs(props, ref) {
    const listRef = React.useRef(null);
    const containerRef = useForkRef(ref, listRef);
    const items = [];
    React.Children.forEach(props.children, (child, index) => {
        if (React.isValidElement(child)) {
            if (child.key === undefined || child.key === null) {
                child = React.cloneElement(child, { key: index });
            }
            items.push(child);
        }
    });
    const [visibleItemsCount, setVisibleItemsCount] = React.useState(items.length);
    const [calculated, setCalculated] = React.useState(false);
    const recalculate = (visibleItems) => {
        const list = listRef.current;
        if (!list) {
            return;
        }
        const listItems = Array.from(list.children);
        if (listItems.length === 0) {
            return;
        }
        const containerWidth = list.offsetWidth;
        let newVisibleItemsCount = 0;
        let calculatedWidth = 0;
        let maxItems = props.maxItems || Infinity;
        let rootWidth = 0;
        if (props.showRoot) {
            const item = listItems.shift();
            if (item) {
                rootWidth = item.scrollWidth;
                calculatedWidth += rootWidth;
            }
            newVisibleItemsCount++;
        }
        const hasMenu = items.length > visibleItems;
        if (hasMenu) {
            const item = listItems.shift();
            if (item) {
                calculatedWidth += item.offsetWidth;
            }
            maxItems--;
        }
        if (props.showRoot && calculatedWidth >= containerWidth) {
            calculatedWidth -= rootWidth;
            newVisibleItemsCount--;
        }
        const lastItem = listItems.pop();
        if (lastItem) {
            calculatedWidth += Math.min(lastItem.offsetWidth, 200);
            if (calculatedWidth < containerWidth) {
                newVisibleItemsCount++;
            }
        }
        for (let i = listItems.length - 1; i >= 0; i--) {
            const item = listItems[i];
            calculatedWidth += item.offsetWidth;
            if (calculatedWidth >= containerWidth) {
                break;
            }
            newVisibleItemsCount++;
        }
        newVisibleItemsCount = Math.max(Math.min(maxItems, newVisibleItemsCount), 1);
        if (newVisibleItemsCount === visibleItemsCount) {
            setCalculated(true);
        }
        else {
            setVisibleItemsCount(newVisibleItemsCount);
        }
    };
    const handleResize = React.useCallback(() => {
        setCalculated(false);
        setVisibleItemsCount(items.length);
    }, [items.length]);
    useResizeObserver({
        ref: listRef,
        onResize: handleResize,
    });
    const lastChildren = React.useRef(null);
    React.useLayoutEffect(() => {
        if (calculated && props.children !== lastChildren.current) {
            lastChildren.current = props.children;
            setCalculated(false);
            setVisibleItemsCount(items.length);
        }
    }, [calculated, items.length, props.children]);
    React.useLayoutEffect(() => {
        if (!calculated) {
            recalculate(visibleItemsCount);
        }
    });
    const { navigate } = props;
    let contents = items;
    if (items.length > visibleItemsCount) {
        contents = [];
        const breadcrumbs = [...items];
        let endItems = visibleItemsCount;
        if (props.showRoot && visibleItemsCount > 1) {
            const rootItem = breadcrumbs.shift();
            if (rootItem) {
                contents.push(rootItem);
            }
            endItems--;
        }
        const hiddenItems = breadcrumbs.slice(0, -endItems);
        const menuItem = (_jsx(BreadcrumbItem, { itemType: "menu", children: _jsx(DropdownMenu, { items: hiddenItems.map((el, index) => {
                    return Object.assign(Object.assign({}, el.props), { text: el.props.children, disabled: props.disabled, items: [], action: (event) => {
                            var _a;
                            if (typeof props.onAction === 'function') {
                                props.onAction((_a = el.key) !== null && _a !== void 0 ? _a : index);
                            }
                            // TODO: move this logic to DropdownMenu
                            const target = event.currentTarget;
                            if (typeof navigate === 'function' &&
                                target instanceof HTMLAnchorElement) {
                                if (el.props.href && shouldClientNavigate(target, event)) {
                                    event.preventDefault();
                                    navigate(el.props.href, el.props.routerOptions);
                                }
                            }
                        } });
                }), popupProps: {
                    className: b('popup', {
                        staircase: props.popupStyle === 'staircase',
                    }),
                    placement: props.popupPlacement,
                }, renderSwitcher: ({ onClick }) => (_jsx(Button, { title: i18n('label_more'), className: b('more-button'), onClick: onClick, size: "s", view: "flat", disabled: props.disabled, children: _jsx(Button.Icon, { children: "..." }) })) }) }));
        contents.push(menuItem);
        contents.push(...breadcrumbs.slice(-endItems));
    }
    const lastIndex = contents.length - 1;
    const breadcrumbItems = contents.map((child, index) => {
        var _a;
        const isCurrent = index === lastIndex;
        const key = (_a = child.key) !== null && _a !== void 0 ? _a : index;
        const handleAction = () => {
            if (typeof props.onAction === 'function') {
                props.onAction(key);
            }
        };
        return (_jsxs("li", { className: b('item', { calculating: !calculated }), children: [_createElement(BreadcrumbItem, Object.assign({}, child.props, { key: key, current: isCurrent, disabled: props.disabled || child.props.disabled, onAction: handleAction, navigate: navigate }), child.props.children), isCurrent ? null : _jsx(BreadcrumbsSeparator, { separator: props.separator })] }, index));
    });
    return (_jsx("ol", Object.assign({ ref: containerRef }, filterDOMProps(props, { labelable: true }), { "data-qa": props.qa, className: b(null, props.className), style: props.style, children: breadcrumbItems })));
});
Breadcrumbs.Item = Item;
Breadcrumbs.displayName = 'Breadcrumbs';
export { Item as BreadcrumbsItem };
